plugins {
    id 'groovy-gradle-plugin'
    id 'maven-publish'
    id 'com.gradle.plugin-publish' version '0.12.0'
}

version = project.version != 'unspecified' ? project.version : file('VERSION').text.trim()
group = 'net.gradleutil'

repositories {
    maven { url "https://jitpack.io" }
    mavenLocal()
    mavenCentral()
}

dependencies {
    implementation('gg.jte:jte:2.0.3')
    implementation('gg.jte:jte-runtime:2.0.3')
    implementation('net.gradleutil:conf-gen:1.1.0')
}

javadoc {
    failOnError = false
}

java {
    withJavadocJar()
    withSourcesJar()
}

mhfModel {
    plugin {
        mhf = file('src/main/mhf/plugin.mhf')
        modelName = 'JteGradlePlugin'
        packageName = 'net.gradleutil.jte'
        outputDir = file('src/main/groovy/net/gradleutil/jte/plugin')
    }
}

pluginBundle {
    website = 'https://github.com/gradleutil/gradle-jte'
    vcsUrl = 'https://github.com/gradleutil/gradle-jte'
    description = 'Precompile all jte templates to Java classes during gradle build'
    tags = ['templates', 'jte']
}

gradlePlugin {
    plugins {
        gradleconf {
            id = 'net.gradleutil.gradle-jte'
            displayName = 'gradleutil jte gradle plugin'
            description = 'Precompile all jte templates to Java classes during gradle build'
            implementationClass = 'net.gradleutil.jte.gradle.JteGradle'
        }
    }
}


testing {
    suites {
        test {
            useSpock('2.0-groovy-3.0')
        }
        testPlugin(JvmTestSuite) {
            useSpock('2.0-groovy-3.0')
            dependencies {
                implementation project
            }

            targets {
                all {
                    testTask.configure { shouldRunAfter(test) }
                }
            }
        }
    }
}

gradlePlugin.testSourceSets(sourceSets.testPlugin)


tasks.named('check') { task -> // Include testFunctionality as part of the check lifecycle
    task.dependsOn(testing.suites.testPlugin)
}

tasks.withType(Test) {
    group = 'tests'
    testLogging { it.events "passed", "skipped", "failed" }
    testLogging.showStandardStreams = true
    testLogging.showCauses = true
    testLogging.exceptionFormat('full')
}

tasks.withType(AbstractPublishToMaven) { publishTask ->
    def printInfo = { AbstractPublishToMaven task, String repoPath ->
        task.publication.with { p ->
            def sb = new StringBuilder()
            p.artifacts.each {
                String artifactPath = p.groupId.replace(".", "/") + "/" + p.artifactId + "/" + p.version + "/"
                sb.append('\n  ' + repoPath).append(artifactPath)
                        .append(p.artifactId).append('-' + p.version)
                        .append(it.classifier ? '-' + it.classifier : '').append('.' + it.extension)
            }
            logger.lifecycle("Published ${p.groupId}:${p.artifactId}:${p.version}${sb.toString()}")
        }
    }
    doLast {
        if (publishTask instanceof PublishToMavenRepository) {
            printInfo(publishTask, publishTask.repository.url.toString())
        } else {
            String repoPath = repositories.mavenLocal().url.toURL().getFile()
            printInfo(publishTask, repoPath)
        }
    }
}